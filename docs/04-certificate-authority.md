# Provisioning a CA and Generating TLS Certificates

## Understanding CA, TLS, SSL

**Encryption** is a way to convert data into special text (that is un-processable in itself) so that only the *encryptor* and the person intended to receive the data can convert it back *a.k.a decrypt* it to the original form.

This conversion happens with the help of a 🔑! which again is just a random string text. !


```javascript

const key = AES.random() // this is shared between the encryptor and the decryptor 

const encryptedMessage = functionThatEncrypts(plainMessage, key) 

const plainMessage = functionThatDecrypts(encryptedMessage, key)
```

Notice in the above example we used the same `key` to encrypt as well as decrypt the message. This type of encryption is called **Symmetric encryption** and when we have two separate keys it's **Asymmetric encryption**

A commonly followed process to do the same - Advanced Encryption Standard [**AES**](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) 


---


Now think of a case where two computers that **knew each other beforehand** have to share some secret data over the internet . How can they do it ?

1. Decide on a common `key` while being **offline** to use, and not share it with any other computer.

2. Then use that key to encrypt and decrypt data while talking **online** 

As a result no-one **online or offline** can possibly make out what they are talking ! This is a secure connection 🙌 powered by **Symmetric encryption** 


---


But more often in real life two computers have to talk for the first time **online** . So if they decide on a common key they would have to first share the common key with each other in plain text **online** !

That's crazy because the internet is like an open connection and any person sniffing on the network can make out what your *apparently secret* key is ! 🔐 

And then use it to imitate `Computer A` to `Computer B` and `Computer B` to `Computer A` whilst getting to see the entire chat 💭 that's going on. And worse, the attacker can **manipulate packets** coming from `Computer A` and send  to `Computer B` for his benefit ! like asking for credit card details via supplying wrong HTML to legitimately requested webpages. 💥 ٩(๏_๏)۶ 💥

The above is called **MITM - Man in the Middle attack**

---

### Solution for the above problem -

Send the secret key via a  rocket to the other computer's location each time you wanna make a request !

![Rocket](https://dev-to-uploads.s3.amazonaws.com/i/415v3y8j4qs8nei39f48.gif)

But it's a little expensive !

So we use **Asymmetric encryption** to address the issue.

This involves 2 kinds of keys - One for encryption which is publicly available and the other for decryption which is private.

**Important part** is that any data which is encrypted using public key can only be decrypted using the private key 🔑


```javascript

const { publicKey, privateKey } = AES.generateKeyPair()

const encryptedText = functionThatEncrypts(plainText, publicKey)

const plainText = functionThatDecrypts(encryptedText, privateKey)
```

Now we'll learn how we can use that functionality to send a common key that both the computers agree to, **online**, except that this time it will be encrypted ! This does not leave room for deciphering intercepted data.

1. `Computer A` initiates a connection to `Computer B` by sending a plain text hello ! 👋 This of course contains information like srcIP, srcPort, etc.

2. `Computer B` then sends its **public key** to `Computer A` as a response packet

3. `Computer A` now uses the public key to encrypt another key 🔑 of its own which will later work as the common key. This encrypted data is known an `Premaster Secret` and will be sent to `Computer B`

```javascript

// On side of Computer A

const finalKey = UUID.random(128) // generated by Computer A
const publicKey = receiveFromComputerB() // Step 2

const premasterSecret = functionThatEncrypts(finalKey, publicKey)

sendToComputerB(premasterSecret)

```

> Remember: Our goal is to share a common key without the fear of being deciphered on interception - so in this way we can get back to talking with **Symmetric encryption**


`Computer B` can decrypt it using its **private key**. And no other computer (even `Computer A`) at this point can decrypt the premaster secret.

```javascript

// On side of Computer B

const premasterSecret = receiveFromComputerA()

const privateKey = .... // generated as a pair along with public key

const finalKey = functionThatDecrypts(premasterSecret, privateKey)

```

*Now both computers share a common key * `finalKey` !

The above 3 step process is called the **Transport Layer Security Handshake**. (TLS)

---

Buuuu......t we are not done yet because clearly in `Step 2` the public key transfer to `Computer A` can be intercepted by a man in the middle who can totally represent himself falsely to `Computer A`. 

**Hence `Computer A` needs to be able to verify that the public key it receives is from `Computer B`.**

---

### Solution -  SSL (Secure socket layer)

Yes ! `Computer B` needs to send the **pubilcKey** through  a privately signed SSL certificate and not directly. The reason is `Computer A` on the receiving end can get the certificate verified through a **Certificate Authority** (CA) which is a 3rd party service that helps verify server profiles on the internet !

In this lab you will provision a [PKI Infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure) using CloudFlare's PKI toolkit, [cfssl](https://github.com/cloudflare/cfssl), then use it to bootstrap a Certificate Authority, and generate TLS certificates for the following components: etcd, kube-apiserver, kube-controller-manager, kube-scheduler, kubelet, and kube-proxy.

## Certificate Authority

In this section you will provision a Certificate Authority that can be used to generate additional TLS certificates.

Generate the CA configuration file, certificate, and private key:

```
{

cat > ca-config.json <<EOF
{
  "signing": {
    "default": {
      "expiry": "8760h"
    },
    "profiles": {
      "kubernetes": {
        "usages": ["signing", "key encipherment", "server auth", "client auth"],
        "expiry": "8760h"
      }
    }
  }
}
EOF

cat > ca-csr.json <<EOF
{
  "CN": "Kubernetes",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "Kubernetes",
      "OU": "CA",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert -initca ca-csr.json | cfssljson -bare ca

}
```

Results:

```
ca-key.pem
ca.pem
```

## Client and Server Certificates

In this section you will generate client and server certificates for each Kubernetes component and a client certificate for the Kubernetes `admin` user.

### The Admin Client Certificate

Generate the `admin` client certificate and private key:

```
{

cat > admin-csr.json <<EOF
{
  "CN": "admin",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "system:masters",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  admin-csr.json | cfssljson -bare admin

}
```

Results:

```
admin-key.pem
admin.pem
```

### The Kubelet Client Certificates

Kubernetes uses a [special-purpose authorization mode](https://kubernetes.io/docs/admin/authorization/node/) called Node Authorizer, that specifically authorizes API requests made by [Kubelets](https://kubernetes.io/docs/concepts/overview/components/#kubelet). In order to be authorized by the Node Authorizer, Kubelets must use a credential that identifies them as being in the `system:nodes` group, with a username of `system:node:<nodeName>`. In this section you will create a certificate for each Kubernetes worker node that meets the Node Authorizer requirements.

Generate a certificate and private key for each Kubernetes worker node:

```
for instance in worker-0 worker-1 worker-2; do
cat > ${instance}-csr.json <<EOF
{
  "CN": "system:node:${instance}",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "system:nodes",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

EXTERNAL_IP=$(gcloud compute instances describe ${instance} \
  --format 'value(networkInterfaces[0].accessConfigs[0].natIP)')

INTERNAL_IP=$(gcloud compute instances describe ${instance} \
  --format 'value(networkInterfaces[0].networkIP)')

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -hostname=${instance},${EXTERNAL_IP},${INTERNAL_IP} \
  -profile=kubernetes \
  ${instance}-csr.json | cfssljson -bare ${instance}
done
```

Results:

```
worker-0-key.pem
worker-0.pem
worker-1-key.pem
worker-1.pem
worker-2-key.pem
worker-2.pem
```

### The Controller Manager Client Certificate

Generate the `kube-controller-manager` client certificate and private key:

```
{

cat > kube-controller-manager-csr.json <<EOF
{
  "CN": "system:kube-controller-manager",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "system:kube-controller-manager",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager

}
```

Results:

```
kube-controller-manager-key.pem
kube-controller-manager.pem
```


### The Kube Proxy Client Certificate

Generate the `kube-proxy` client certificate and private key:

```
{

cat > kube-proxy-csr.json <<EOF
{
  "CN": "system:kube-proxy",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "system:node-proxier",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  kube-proxy-csr.json | cfssljson -bare kube-proxy

}
```

Results:

```
kube-proxy-key.pem
kube-proxy.pem
```

### The Scheduler Client Certificate

Generate the `kube-scheduler` client certificate and private key:

```
{

cat > kube-scheduler-csr.json <<EOF
{
  "CN": "system:kube-scheduler",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "system:kube-scheduler",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  kube-scheduler-csr.json | cfssljson -bare kube-scheduler

}
```

Results:

```
kube-scheduler-key.pem
kube-scheduler.pem
```


### The Kubernetes API Server Certificate

The `kubernetes-the-hard-way` static IP address will be included in the list of subject alternative names for the Kubernetes API Server certificate. This will ensure the certificate can be validated by remote clients.

Generate the Kubernetes API Server certificate and private key:

```
{

KUBERNETES_PUBLIC_ADDRESS=$(gcloud compute addresses describe kubernetes-the-hard-way \
  --region $(gcloud config get-value compute/region) \
  --format 'value(address)')

KUBERNETES_HOSTNAMES=kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.svc.cluster.local

cat > kubernetes-csr.json <<EOF
{
  "CN": "kubernetes",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "Kubernetes",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -hostname=10.32.0.1,10.240.0.10,10.240.0.11,10.240.0.12,${KUBERNETES_PUBLIC_ADDRESS},127.0.0.1,${KUBERNETES_HOSTNAMES} \
  -profile=kubernetes \
  kubernetes-csr.json | cfssljson -bare kubernetes

}
```

> The Kubernetes API server is automatically assigned the `kubernetes` internal dns name, which will be linked to the first IP address (`10.32.0.1`) from the address range (`10.32.0.0/24`) reserved for internal cluster services during the [control plane bootstrapping](08-bootstrapping-kubernetes-controllers.md#configure-the-kubernetes-api-server) lab.

Results:

```
kubernetes-key.pem
kubernetes.pem
```

## The Service Account Key Pair

The Kubernetes Controller Manager leverages a key pair to generate and sign service account tokens as described in the [managing service accounts](https://kubernetes.io/docs/admin/service-accounts-admin/) documentation.

Generate the `service-account` certificate and private key:

```
{

cat > service-account-csr.json <<EOF
{
  "CN": "service-accounts",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "Portland",
      "O": "Kubernetes",
      "OU": "Kubernetes The Hard Way",
      "ST": "Oregon"
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  service-account-csr.json | cfssljson -bare service-account

}
```

Results:

```
service-account-key.pem
service-account.pem
```


## Distribute the Client and Server Certificates

Copy the appropriate certificates and private keys to each worker instance:

```
for instance in worker-0 worker-1 worker-2; do
  gcloud compute scp ca.pem ${instance}-key.pem ${instance}.pem ${instance}:~/
done
```

Copy the appropriate certificates and private keys to each controller instance:

```
for instance in controller-0 controller-1 controller-2; do
  gcloud compute scp ca.pem ca-key.pem kubernetes-key.pem kubernetes.pem \
    service-account-key.pem service-account.pem ${instance}:~/
done
```

> The `kube-proxy`, `kube-controller-manager`, `kube-scheduler`, and `kubelet` client certificates will be used to generate client authentication configuration files in the next lab.

Next: [Generating Kubernetes Configuration Files for Authentication](05-kubernetes-configuration-files.md)



## Resources used to learn PKI and TLS:

### PKI:
This is a technology which is used to create, manage and revoke digital certificates and also to manage public key encryption.
https://www.youtube.com/watch?v=i-rtxrEz_E8

### TLS

https://www.youtube.com/watch?v=0TLDTodL7Lc


### TLS handshake:
This is used to transfer the data between the devices securely using cryptography. 
There will be a series of steps which happens between the participating devices in order to establish a secure and encrypted connection between them. 
Once all these steps are finished, the devices communicate by using a single key to encrypt and decrypt the data.
It is explained more clearly in the following resources.
https://www.youtube.com/watch?v=cuR05y_2Gxc
https://www.youtube.com/watch?v=86cQJ0MMses

https://docs.microsoft.com/en-us/windows/win32/secauthn/tls-handshake-protocol
